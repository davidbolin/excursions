\name{tricontourmap}
\alias{tricontourmap}
\alias{tricontourmap.inla.mesh}
\alias{tricontourmap.matrix}
\alias{tricontourmap.list}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
  Calculate contour curves on a triangulation
}
\description{
  Calculates contour curves and regions between them, for functions
  defined on a triangulation
}
\usage{
tricontourmap(x, z, nlevels = 10,
              levels = pretty(range(z, na.rm = TRUE), nlevels),
              ...)
\method{tricontourmap}{inla.mesh}(x, z, nlevels = 10,
              levels = pretty(range(z, na.rm = TRUE), nlevels),
              ...)
\method{tricontourmap}{matrix}(x, z, nlevels = 10,
              levels = pretty(range(z, na.rm = TRUE), nlevels),
              loc,
              ...)
\method{tricontourmap}{list}(x, z, nlevels = 10,
           levels = pretty(range(z, na.rm = TRUE), nlevels),
           loc,
           type=c("+", "-"), tol=1e-7,
           ...)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{x}{
    An object generated by a call to
    \code{\link{INLA::inla.mesh.2d}} or
    \code{\link{INLA::inla.mesh.create}},
    a triangle-vertex index matrix, or a list of triangulation
    information, \code{list(loc, graph=list(tv))}.
}
\item{z}{a vector containing the values to be contoured (\code{NA}s are
  allowed).}
\item{nlevels}{number of contour levels desired if and only if
          \code{levels} is not supplied.  }
\item{levels}{numeric vector of levels at which to calculate contour lines.
}
\item{loc}{coordinate matrix, to be supplied when \code{x} is given as a
  triangle-vertex index matrix only.
}
\item{type}{\code{"+"} or \code{"-"}, indicating positive or negative
  association. For \code{+}, the generated contours enclose regions
  where \eqn{u_1 \leq z < u_2}, for \code{-} the regions fulfil \eqn{u_1
  < z \leq u_2}.}
\item{tol}{
tolerance for determining if the value at a vertex lies on a level.
}
\item{output}{The format of the generated output.  Implemented options
are \code{"sp"} (default) and \code{"inla.mesh.segment"} (requires the
INLA package).
}
\item{...}{
  Additional arguments passed to the other methods.
}
}
\details{

}
\value{
  A list:
  \item{contour}{A list of \code{sp} or \code{inla.mesh.segment} objects
    defining countour curves (level sets)}
  \item{map}{A list of \code{sp} or \code{inla.mesh.segment} objects
    enclosing regions between level sets}
}
%%\references{
%% ~put references to the literature/web site here ~
%%}
\author{
Finn Lindgren
}
%%\note{
%%  ~~further notes~~
%%}

%% ~Make other sections like Warning with \section{Warning }{....} ~

%%\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
%%}
\examples{
\dontrun{
if (require(INLA)) {
  #Generate mesh and SPDE model
  n.lattice = 40
  x=seq(from=0,to=10,length.out=n.lattice)
  lattice=inla.mesh.lattice(x=x,y=x)
  mesh=inla.mesh.create(lattice=lattice, extend=FALSE, refine=FALSE)
  spde <- inla.spde2.matern(mesh, alpha=2)

  #Generate an artificial sample
  sigma2.e = 0.01
  n.obs=1000
  obs.loc = cbind(runif(n.obs)*diff(range(x))+min(x),
                  runif(n.obs)*diff(range(x))+min(x))
  Q = inla.spde2.precision(spde, theta=c(log(sqrt(0.5)), log(sqrt(1))))
  x = inla.qsample(Q=Q)
  A = inla.spde.make.A(mesh=mesh,loc=obs.loc)
  Y = as.vector(A \%*\% x + rnorm(n.obs)*sqrt(sigma2.e))

  ## Calculate posterior
  Q.post = (Q + (t(A)\%*\%A)/sigma2.e)
  mu.post = as.vector(solve(Q.post,(t(A)\%*\%Y)/sigma2.e))
  vars.post = excursions.variances(chol(Q.post))

  ## Calculate contour map with two levels
  map = contourmap(n.levels = 2, mu = mu.post, Q = Q.post,
                   alpha=0.1, F.limit = 0.9)

  ## Calculate the continuous representation
  sets <- continuous(map, mesh, alpha=0.1)

  ## Calculate continuous contours
  setsc = tricontourmap(mesh, z=mu.post, levels=map$meta$levels)

  ## Plot the results
  reo = mesh$idx$lattice
  cols = contourmap.colors(map, col=heat.colors(100, 1),
                           credible.col = grey(0.5, 1))
  cols2 = contourmap.colors(map, col=heat.colors(100, 0.5),
                            credible.col = grey(0.5, 0))
  names(cols) = as.character(-1:2)
  names(cols2) = as.character(-1:2)

  par(mfrow = c(2,2))
  image(matrix(mu.post[reo],n.lattice,n.lattice),main="mean",axes=F)
  image(matrix(sqrt(vars.post[reo]),n.lattice,n.lattice),main="sd", axes = F)
  image(matrix(map$M[reo],n.lattice,n.lattice),col=cols,axes=F)
  idx.setsc = setdiff(names(setsc$map), "-1")
  idx.M = setdiff(names(sets$M), "-1")
  plot(setsc$map[idx.setsc], col=cols2[idx.setsc])
  plot(sets$M[idx.M], col=cols[idx.M], border=FALSE,add=TRUE)
}
}
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
%%\keyword{ ~kwd1 }
%%\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line
